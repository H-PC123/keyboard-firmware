   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.unselect_rows,"ax",@progbits
  12               	unselect_rows:
  13               	.LFB12:
  14               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <avr/io.h>
  24:matrix.c      **** #include <util/delay.h>
  25:matrix.c      **** #include "print.h"
  26:matrix.c      **** #include "debug.h"
  27:matrix.c      **** #include "util.h"
  28:matrix.c      **** #include "matrix.h"
  29:matrix.c      **** 
  30:matrix.c      **** 
  31:matrix.c      **** #ifndef DEBOUNCE
  32:matrix.c      **** #   define DEBOUNCE	5
  33:matrix.c      **** #endif
  34:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  35:matrix.c      **** 
  36:matrix.c      **** /* matrix state(1:on, 0:off) */
  37:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  38:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  39:matrix.c      **** 
  40:matrix.c      **** static matrix_row_t read_cols(void);
  41:matrix.c      **** static void init_cols(void);
  42:matrix.c      **** static void unselect_rows(void);
  43:matrix.c      **** static void select_row(uint8_t row);
  44:matrix.c      **** 
  45:matrix.c      **** 
  46:matrix.c      **** void matrix_init(void)
  47:matrix.c      **** {
  48:matrix.c      **** 	
  49:matrix.c      ****     MCUCR |= (1<<JTD);
  50:matrix.c      ****     MCUCR |= (1<<JTD);
  51:matrix.c      **** 	
  52:matrix.c      ****     // initialize row and col
  53:matrix.c      ****     unselect_rows();
  54:matrix.c      ****     init_cols();
  55:matrix.c      **** 
  56:matrix.c      ****     // initialize matrix state: all keys off
  57:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  58:matrix.c      ****         matrix[i] = 0;
  59:matrix.c      ****         matrix_debouncing[i] = 0;
  60:matrix.c      ****     }
  61:matrix.c      **** }
  62:matrix.c      **** 
  63:matrix.c      **** uint8_t matrix_scan(void)
  64:matrix.c      **** {
  65:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  66:matrix.c      ****         select_row(i);
  67:matrix.c      ****         _delay_us(30);  // without this wait read unstable value.
  68:matrix.c      ****         matrix_row_t cols = read_cols();
  69:matrix.c      ****         if (matrix_debouncing[i] != cols) {
  70:matrix.c      ****             matrix_debouncing[i] = cols;
  71:matrix.c      ****             if (debouncing) {
  72:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
  73:matrix.c      ****             }
  74:matrix.c      ****             debouncing = DEBOUNCE;
  75:matrix.c      ****         }
  76:matrix.c      ****         unselect_rows();
  77:matrix.c      ****     }
  78:matrix.c      **** 
  79:matrix.c      ****     if (debouncing) {
  80:matrix.c      ****         if (--debouncing) {
  81:matrix.c      ****             _delay_ms(1);
  82:matrix.c      ****         } else {
  83:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  84:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
  85:matrix.c      ****             }
  86:matrix.c      ****         }
  87:matrix.c      ****     }
  88:matrix.c      **** 
  89:matrix.c      ****     return 1;
  90:matrix.c      **** }
  91:matrix.c      **** 
  92:matrix.c      **** inline
  93:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
  94:matrix.c      **** {
  95:matrix.c      ****     return matrix[row];
  96:matrix.c      **** }
  97:matrix.c      **** 
  98:matrix.c      **** /* Column pin configuration
  99:matrix.c      ****  * col: 0   1   2   3   4   5   6   7   8   9   10  11  12  13	14	15	16	17
 100:matrix.c      ****  * pin: B6	B5	B4	D7	D4	D5	C7	C6	D3	D2	D1	D0	B7	B3	B2	B1	B0	E6
 101:matrix.c      ****  */
 102:matrix.c      **** static void  init_cols(void)
 103:matrix.c      **** {
 104:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 105:matrix.c      ****     DDRB  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 106:matrix.c      ****     PORTB |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 107:matrix.c      ****     DDRD  &= ~(1<<7 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 108:matrix.c      ****     PORTD |=  (1<<7 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 109:matrix.c      ****     DDRC  &= ~(1<<7 | 1<<6);
 110:matrix.c      ****     PORTC |=  (1<<7 | 1<<6);
 111:matrix.c      ****     DDRE  &= ~(1<<6);
 112:matrix.c      ****     PORTE |=  (1<<6);
 113:matrix.c      **** }
 114:matrix.c      **** 
 115:matrix.c      **** static matrix_row_t read_cols(void)
 116:matrix.c      **** {
 117:matrix.c      ****     return (PINB&(1<<6) ? 0 : (1UL<<0)) |
 118:matrix.c      ****            (PINB&(1<<5) ? 0 : (1UL<<1)) |
 119:matrix.c      ****            (PINB&(1<<4) ? 0 : (1UL<<2)) |
 120:matrix.c      ****            (PIND&(1<<7) ? 0 : (1UL<<3)) |
 121:matrix.c      ****            (PIND&(1<<4) ? 0 : (1UL<<4)) |
 122:matrix.c      ****            (PIND&(1<<5) ? 0 : (1UL<<5)) |
 123:matrix.c      ****            (PINC&(1<<7) ? 0 : (1UL<<6)) |
 124:matrix.c      ****            (PINC&(1<<6) ? 0 : (1UL<<7)) |
 125:matrix.c      ****            (PIND&(1<<3) ? 0 : (1UL<<8)) |
 126:matrix.c      ****            (PIND&(1<<2) ? 0 : (1UL<<9)) |
 127:matrix.c      ****            (PIND&(1<<1) ? 0 : (1UL<<10)) |
 128:matrix.c      ****            (PIND&(1<<0) ? 0 : (1UL<<11)) |
 129:matrix.c      ****            (PINB&(1<<7) ? 0 : (1UL<<12)) |
 130:matrix.c      ****            (PINB&(1<<3) ? 0 : (1UL<<13)) |
 131:matrix.c      ****            (PINB&(1<<2) ? 0 : (1UL<<14)) |
 132:matrix.c      ****            (PINB&(1<<1) ? 0 : (1UL<<15)) |
 133:matrix.c      ****            (PINB&(1<<0) ? 0 : (1UL<<16)) |
 134:matrix.c      ****            (PINE&(1<<6) ? 0 : (1UL<<17));
 135:matrix.c      **** }
 136:matrix.c      **** 
 137:matrix.c      **** /* Row pin configuration
 138:matrix.c      ****  * row: 0   1   2   3   4	5
 139:matrix.c      ****  * pin: F0  F1  F4  F5  F6	F7	
 140:matrix.c      ****  */
 141:matrix.c      **** static void unselect_rows(void)
 142:matrix.c      **** {
  15               		.loc 1 142 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 143:matrix.c      ****     // Hi-Z(DDR:0, PORT:0) to unselect
 144:matrix.c      ****     DDRF  &= ~0b11110011;
  21               		.loc 1 144 0
  22 0000 80B3      		in r24,0x10
  23 0002 8C70      		andi r24,lo8(12)
  24 0004 80BB      		out 0x10,r24
 145:matrix.c      ****     PORTF &= ~0b11110011;
  25               		.loc 1 145 0
  26 0006 81B3      		in r24,0x11
  27 0008 8C70      		andi r24,lo8(12)
  28 000a 81BB      		out 0x11,r24
  29               	/* epilogue start */
 146:matrix.c      **** }
  30               		.loc 1 146 0
  31 000c 0895      		ret
  32               		.cfi_endproc
  33               	.LFE12:
  35               		.section	.text.matrix_init,"ax",@progbits
  36               	.global	matrix_init
  38               	matrix_init:
  39               	.LFB7:
  47:matrix.c      **** 	
  40               		.loc 1 47 0
  41               		.cfi_startproc
  42               	/* prologue: function */
  43               	/* frame size = 0 */
  44               	/* stack size = 0 */
  45               	.L__stack_usage = 0
  49:matrix.c      ****     MCUCR |= (1<<JTD);
  46               		.loc 1 49 0
  47 0000 85B7      		in r24,0x35
  48 0002 8068      		ori r24,lo8(-128)
  49 0004 85BF      		out 0x35,r24
  50:matrix.c      **** 	
  50               		.loc 1 50 0
  51 0006 85B7      		in r24,0x35
  52 0008 8068      		ori r24,lo8(-128)
  53 000a 85BF      		out 0x35,r24
  53:matrix.c      ****     init_cols();
  54               		.loc 1 53 0
  55 000c 0E94 0000 		call unselect_rows
  56               	.LVL0:
  57               	.LBB15:
  58               	.LBB16:
 105:matrix.c      ****     PORTB |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
  59               		.loc 1 105 0
  60 0010 84B1      		in r24,0x4
  61 0012 14B8      		out 0x4,__zero_reg__
 106:matrix.c      ****     DDRD  &= ~(1<<7 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
  62               		.loc 1 106 0
  63 0014 85B1      		in r24,0x5
  64 0016 8FEF      		ldi r24,lo8(-1)
  65 0018 85B9      		out 0x5,r24
 107:matrix.c      ****     PORTD |=  (1<<7 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
  66               		.loc 1 107 0
  67 001a 8AB1      		in r24,0xa
  68 001c 8074      		andi r24,lo8(64)
  69 001e 8AB9      		out 0xa,r24
 108:matrix.c      ****     DDRC  &= ~(1<<7 | 1<<6);
  70               		.loc 1 108 0
  71 0020 8BB1      		in r24,0xb
  72 0022 8F6B      		ori r24,lo8(-65)
  73 0024 8BB9      		out 0xb,r24
 109:matrix.c      ****     PORTC |=  (1<<7 | 1<<6);
  74               		.loc 1 109 0
  75 0026 87B1      		in r24,0x7
  76 0028 8F73      		andi r24,lo8(63)
  77 002a 87B9      		out 0x7,r24
 110:matrix.c      ****     DDRE  &= ~(1<<6);
  78               		.loc 1 110 0
  79 002c 88B1      		in r24,0x8
  80 002e 806C      		ori r24,lo8(-64)
  81 0030 88B9      		out 0x8,r24
 111:matrix.c      ****     PORTE |=  (1<<6);
  82               		.loc 1 111 0
  83 0032 6E98      		cbi 0xd,6
 112:matrix.c      **** }
  84               		.loc 1 112 0
  85 0034 769A      		sbi 0xe,6
  86               	.LVL1:
  87 0036 E0E0      		ldi r30,lo8(matrix)
  88 0038 F0E0      		ldi r31,hi8(matrix)
  89 003a A0E0      		ldi r26,lo8(matrix_debouncing)
  90 003c B0E0      		ldi r27,hi8(matrix_debouncing)
  91               	.LVL2:
  92               	.L3:
  93               	.LBE16:
  94               	.LBE15:
  95               	.LBB17:
  58:matrix.c      ****         matrix_debouncing[i] = 0;
  96               		.loc 1 58 0 discriminator 3
  97 003e 1192      		st Z+,__zero_reg__
  98 0040 1192      		st Z+,__zero_reg__
  99 0042 1192      		st Z+,__zero_reg__
 100 0044 1192      		st Z+,__zero_reg__
  59:matrix.c      ****     }
 101               		.loc 1 59 0 discriminator 3
 102 0046 1D92      		st X+,__zero_reg__
 103 0048 1D92      		st X+,__zero_reg__
 104 004a 1D92      		st X+,__zero_reg__
 105 004c 1D92      		st X+,__zero_reg__
  57:matrix.c      ****         matrix[i] = 0;
 106               		.loc 1 57 0 discriminator 3
 107 004e 80E0      		ldi r24,hi8(matrix+24)
 108 0050 E030      		cpi r30,lo8(matrix+24)
 109 0052 F807      		cpc r31,r24
 110 0054 01F4      		brne .L3
 111               	/* epilogue start */
 112               	.LBE17:
  61:matrix.c      **** 
 113               		.loc 1 61 0
 114 0056 0895      		ret
 115               		.cfi_endproc
 116               	.LFE7:
 118               		.section	.text.matrix_scan,"ax",@progbits
 119               	.global	matrix_scan
 121               	matrix_scan:
 122               	.LFB8:
  64:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 123               		.loc 1 64 0
 124               		.cfi_startproc
 125 0000 EF92      		push r14
 126               	.LCFI0:
 127               		.cfi_def_cfa_offset 3
 128               		.cfi_offset 14, -2
 129 0002 FF92      		push r15
 130               	.LCFI1:
 131               		.cfi_def_cfa_offset 4
 132               		.cfi_offset 15, -3
 133 0004 1F93      		push r17
 134               	.LCFI2:
 135               		.cfi_def_cfa_offset 5
 136               		.cfi_offset 17, -4
 137 0006 CF93      		push r28
 138               	.LCFI3:
 139               		.cfi_def_cfa_offset 6
 140               		.cfi_offset 28, -5
 141 0008 DF93      		push r29
 142               	.LCFI4:
 143               		.cfi_def_cfa_offset 7
 144               		.cfi_offset 29, -6
 145               	/* prologue: function */
 146               	/* frame size = 0 */
 147               	/* stack size = 5 */
 148               	.L__stack_usage = 5
 149               	.LVL3:
 150 000a C0E0      		ldi r28,lo8(matrix_debouncing)
 151 000c D0E0      		ldi r29,hi8(matrix_debouncing)
  64:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 152               		.loc 1 64 0
 153 000e 7E01      		movw r14,r28
 154               	.LBB32:
  65:matrix.c      ****         select_row(i);
 155               		.loc 1 65 0
 156 0010 10E0      		ldi r17,0
 157               	.LVL4:
 158               	.L37:
 159               	.LBB33:
 160               	.LBB34:
 161               	.LBB35:
 147:matrix.c      **** 
 148:matrix.c      **** static void select_row(uint8_t row)
 149:matrix.c      **** {
 150:matrix.c      ****     // Output low(DDR:1, PORT:0) to select
 151:matrix.c      ****     switch (row) {
 162               		.loc 1 151 0
 163 0012 1330      		cpi r17,lo8(3)
 164 0014 01F4      		brne .+2
 165 0016 00C0      		rjmp .L7
 166 0018 00F0      		brlo .+2
 167 001a 00C0      		rjmp .L8
 168 001c 1130      		cpi r17,lo8(1)
 169 001e 01F4      		brne .+2
 170 0020 00C0      		rjmp .L9
 171 0022 1230      		cpi r17,lo8(2)
 172 0024 01F4      		brne .+2
 173 0026 00C0      		rjmp .L10
 174               	.L6:
 175               	.LVL5:
 152:matrix.c      ****         case 0:
 153:matrix.c      ****             DDRF  |= (1<<0);
 176               		.loc 1 153 0
 177 0028 809A      		sbi 0x10,0
 154:matrix.c      ****             PORTF &= ~(1<<0);
 178               		.loc 1 154 0
 179 002a 8898      		cbi 0x11,0
 180               	.LVL6:
 181               	.L13:
 182               	.LBE35:
 183               	.LBE34:
 184               	.LBB37:
 185               	.LBB38:
 186               		.file 2 "c:\\avr-gcc-7.2.0-x64-mingw\\avr\\include\\util\\delay.h"
   1:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    All rights reserved.
   5:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
   6:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
   9:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
  12:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****      distribution.
  16:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
  17:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
  21:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
  33:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
  35:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
  38:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #  endif
  42:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
  44:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #include <math.h>
  47:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
  48:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** /** \file */
  49:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     \code
  51:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     \endcode
  55:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
  56:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     used.
  60:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
  61:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
  70:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
  79:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
  83:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** */
  84:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
  85:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #endif
  89:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
  90:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     \def F_CPU
  95:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
  97:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 103:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****     integer value.
 107:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****  */
 108:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #endif
 110:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 111:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #endif
 114:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 115:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #  include <math.h>
 119:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #endif
 120:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 121:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** /**
 122:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 124:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 126:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 129:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 131:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 137:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 142:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 147:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    respectively.
 151:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 152:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    \note
 153:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 154:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 164:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****  */
 165:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** void
 166:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** {
 168:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 176:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 179:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 182:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	#else
 183:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 		//round up by default
 184:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	#endif
 186:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 187:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 189:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #else
 190:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	{
 196:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 		{
 200:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 			__ticks --;
 203:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 		}
 204:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 		return;
 205:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	}
 206:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	else
 207:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #endif
 210:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** }
 211:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 212:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** /**
 213:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 215:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 217:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 220:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 222:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 226:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 231:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 236:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    respectively.
 240:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 241:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    \note
 242:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 243:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 253:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****  */
 254:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** void
 255:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** {
 257:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 265:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 268:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 271:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	#else
 272:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 		//round up by default
 273:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	#endif
 275:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 276:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 187               		.loc 2 276 0
 188 002c 80EA      		ldi r24,lo8(-96)
 189 002e 8A95      	1:	dec r24
 190 0030 01F4      		brne 1b
 191               	.LVL7:
 192               	.LBE38:
 193               	.LBE37:
 194               	.LBB39:
 195               	.LBB40:
 117:matrix.c      ****            (PINB&(1<<5) ? 0 : (1UL<<1)) |
 196               		.loc 1 117 0
 197 0032 83B1      		in r24,0x3
 198 0034 8295      		swap r24
 199 0036 8695      		lsr r24
 200 0038 8695      		lsr r24
 201 003a 8370      		andi r24,lo8(3)
 202 003c 91E0      		ldi r25,lo8(1)
 203 003e 8927      		eor r24,r25
 204 0040 90E0      		ldi r25,0
 205 0042 B0E0      		ldi r27,0
 206 0044 A0E0      		ldi r26,0
 207 0046 8170      		andi r24,1
 208 0048 9927      		clr r25
 209 004a AA27      		clr r26
 210 004c BB27      		clr r27
 118:matrix.c      ****            (PINB&(1<<4) ? 0 : (1UL<<2)) |
 211               		.loc 1 118 0
 212 004e 1D99      		sbic 0x3,5
 213 0050 00C0      		rjmp .L42
 214 0052 42E0      		ldi r20,lo8(2)
 215 0054 50E0      		ldi r21,0
 216 0056 60E0      		ldi r22,0
 217 0058 70E0      		ldi r23,0
 218               	.L14:
 117:matrix.c      ****            (PINB&(1<<5) ? 0 : (1UL<<1)) |
 219               		.loc 1 117 0
 220 005a 842B      		or r24,r20
 221 005c 952B      		or r25,r21
 222 005e A62B      		or r26,r22
 223 0060 B72B      		or r27,r23
 119:matrix.c      ****            (PIND&(1<<7) ? 0 : (1UL<<3)) |
 224               		.loc 1 119 0
 225 0062 1C99      		sbic 0x3,4
 226 0064 00C0      		rjmp .L43
 227 0066 44E0      		ldi r20,lo8(4)
 228 0068 50E0      		ldi r21,0
 229 006a 60E0      		ldi r22,0
 230 006c 70E0      		ldi r23,0
 231               	.L15:
 118:matrix.c      ****            (PINB&(1<<4) ? 0 : (1UL<<2)) |
 232               		.loc 1 118 0
 233 006e 842B      		or r24,r20
 234 0070 952B      		or r25,r21
 235 0072 A62B      		or r26,r22
 236 0074 B72B      		or r27,r23
 120:matrix.c      ****            (PIND&(1<<4) ? 0 : (1UL<<4)) |
 237               		.loc 1 120 0
 238 0076 4F99      		sbic 0x9,7
 239 0078 00C0      		rjmp .L44
 240 007a 48E0      		ldi r20,lo8(8)
 241 007c 50E0      		ldi r21,0
 242 007e 60E0      		ldi r22,0
 243 0080 70E0      		ldi r23,0
 244               	.L16:
 119:matrix.c      ****            (PIND&(1<<7) ? 0 : (1UL<<3)) |
 245               		.loc 1 119 0
 246 0082 842B      		or r24,r20
 247 0084 952B      		or r25,r21
 248 0086 A62B      		or r26,r22
 249 0088 B72B      		or r27,r23
 121:matrix.c      ****            (PIND&(1<<5) ? 0 : (1UL<<5)) |
 250               		.loc 1 121 0
 251 008a 4C99      		sbic 0x9,4
 252 008c 00C0      		rjmp .L45
 253 008e 40E1      		ldi r20,lo8(16)
 254 0090 50E0      		ldi r21,0
 255 0092 60E0      		ldi r22,0
 256 0094 70E0      		ldi r23,0
 257               	.L17:
 120:matrix.c      ****            (PIND&(1<<4) ? 0 : (1UL<<4)) |
 258               		.loc 1 120 0
 259 0096 842B      		or r24,r20
 260 0098 952B      		or r25,r21
 261 009a A62B      		or r26,r22
 262 009c B72B      		or r27,r23
 122:matrix.c      ****            (PINC&(1<<7) ? 0 : (1UL<<6)) |
 263               		.loc 1 122 0
 264 009e 4D99      		sbic 0x9,5
 265 00a0 00C0      		rjmp .L46
 266 00a2 40E2      		ldi r20,lo8(32)
 267 00a4 50E0      		ldi r21,0
 268 00a6 60E0      		ldi r22,0
 269 00a8 70E0      		ldi r23,0
 270               	.L18:
 121:matrix.c      ****            (PIND&(1<<5) ? 0 : (1UL<<5)) |
 271               		.loc 1 121 0
 272 00aa 842B      		or r24,r20
 273 00ac 952B      		or r25,r21
 274 00ae A62B      		or r26,r22
 275 00b0 B72B      		or r27,r23
 123:matrix.c      ****            (PINC&(1<<6) ? 0 : (1UL<<7)) |
 276               		.loc 1 123 0
 277 00b2 3799      		sbic 0x6,7
 278 00b4 00C0      		rjmp .L47
 279 00b6 40E4      		ldi r20,lo8(64)
 280 00b8 50E0      		ldi r21,0
 281 00ba 60E0      		ldi r22,0
 282 00bc 70E0      		ldi r23,0
 283               	.L19:
 122:matrix.c      ****            (PINC&(1<<7) ? 0 : (1UL<<6)) |
 284               		.loc 1 122 0
 285 00be 842B      		or r24,r20
 286 00c0 952B      		or r25,r21
 287 00c2 A62B      		or r26,r22
 288 00c4 B72B      		or r27,r23
 124:matrix.c      ****            (PIND&(1<<3) ? 0 : (1UL<<8)) |
 289               		.loc 1 124 0
 290 00c6 3699      		sbic 0x6,6
 291 00c8 00C0      		rjmp .L48
 292 00ca 40E8      		ldi r20,lo8(-128)
 293 00cc 50E0      		ldi r21,0
 294 00ce 60E0      		ldi r22,0
 295 00d0 70E0      		ldi r23,0
 296               	.L20:
 123:matrix.c      ****            (PINC&(1<<6) ? 0 : (1UL<<7)) |
 297               		.loc 1 123 0
 298 00d2 842B      		or r24,r20
 299 00d4 952B      		or r25,r21
 300 00d6 A62B      		or r26,r22
 301 00d8 B72B      		or r27,r23
 125:matrix.c      ****            (PIND&(1<<2) ? 0 : (1UL<<9)) |
 302               		.loc 1 125 0
 303 00da 4B99      		sbic 0x9,3
 304 00dc 00C0      		rjmp .L49
 305 00de 40E0      		ldi r20,0
 306 00e0 51E0      		ldi r21,lo8(1)
 307 00e2 60E0      		ldi r22,0
 308 00e4 70E0      		ldi r23,0
 309               	.L21:
 124:matrix.c      ****            (PIND&(1<<3) ? 0 : (1UL<<8)) |
 310               		.loc 1 124 0
 311 00e6 842B      		or r24,r20
 312 00e8 952B      		or r25,r21
 313 00ea A62B      		or r26,r22
 314 00ec B72B      		or r27,r23
 126:matrix.c      ****            (PIND&(1<<1) ? 0 : (1UL<<10)) |
 315               		.loc 1 126 0
 316 00ee 4A99      		sbic 0x9,2
 317 00f0 00C0      		rjmp .L50
 318 00f2 40E0      		ldi r20,0
 319 00f4 52E0      		ldi r21,lo8(2)
 320 00f6 60E0      		ldi r22,0
 321 00f8 70E0      		ldi r23,0
 322               	.L22:
 125:matrix.c      ****            (PIND&(1<<2) ? 0 : (1UL<<9)) |
 323               		.loc 1 125 0
 324 00fa 842B      		or r24,r20
 325 00fc 952B      		or r25,r21
 326 00fe A62B      		or r26,r22
 327 0100 B72B      		or r27,r23
 127:matrix.c      ****            (PIND&(1<<0) ? 0 : (1UL<<11)) |
 328               		.loc 1 127 0
 329 0102 4999      		sbic 0x9,1
 330 0104 00C0      		rjmp .L51
 331 0106 40E0      		ldi r20,0
 332 0108 54E0      		ldi r21,lo8(4)
 333 010a 60E0      		ldi r22,0
 334 010c 70E0      		ldi r23,0
 335               	.L23:
 126:matrix.c      ****            (PIND&(1<<1) ? 0 : (1UL<<10)) |
 336               		.loc 1 126 0
 337 010e 842B      		or r24,r20
 338 0110 952B      		or r25,r21
 339 0112 A62B      		or r26,r22
 340 0114 B72B      		or r27,r23
 128:matrix.c      ****            (PINB&(1<<7) ? 0 : (1UL<<12)) |
 341               		.loc 1 128 0
 342 0116 4899      		sbic 0x9,0
 343 0118 00C0      		rjmp .L52
 344 011a 40E0      		ldi r20,0
 345 011c 58E0      		ldi r21,lo8(8)
 346 011e 60E0      		ldi r22,0
 347 0120 70E0      		ldi r23,0
 348               	.L24:
 127:matrix.c      ****            (PIND&(1<<0) ? 0 : (1UL<<11)) |
 349               		.loc 1 127 0
 350 0122 842B      		or r24,r20
 351 0124 952B      		or r25,r21
 352 0126 A62B      		or r26,r22
 353 0128 B72B      		or r27,r23
 129:matrix.c      ****            (PINB&(1<<3) ? 0 : (1UL<<13)) |
 354               		.loc 1 129 0
 355 012a 1F99      		sbic 0x3,7
 356 012c 00C0      		rjmp .L53
 357 012e 40E0      		ldi r20,0
 358 0130 50E1      		ldi r21,lo8(16)
 359 0132 60E0      		ldi r22,0
 360 0134 70E0      		ldi r23,0
 361               	.L25:
 128:matrix.c      ****            (PINB&(1<<7) ? 0 : (1UL<<12)) |
 362               		.loc 1 128 0
 363 0136 842B      		or r24,r20
 364 0138 952B      		or r25,r21
 365 013a A62B      		or r26,r22
 366 013c B72B      		or r27,r23
 130:matrix.c      ****            (PINB&(1<<2) ? 0 : (1UL<<14)) |
 367               		.loc 1 130 0
 368 013e 1B99      		sbic 0x3,3
 369 0140 00C0      		rjmp .L54
 370 0142 40E0      		ldi r20,0
 371 0144 50E2      		ldi r21,lo8(32)
 372 0146 60E0      		ldi r22,0
 373 0148 70E0      		ldi r23,0
 374               	.L26:
 129:matrix.c      ****            (PINB&(1<<3) ? 0 : (1UL<<13)) |
 375               		.loc 1 129 0
 376 014a 842B      		or r24,r20
 377 014c 952B      		or r25,r21
 378 014e A62B      		or r26,r22
 379 0150 B72B      		or r27,r23
 131:matrix.c      ****            (PINB&(1<<1) ? 0 : (1UL<<15)) |
 380               		.loc 1 131 0
 381 0152 1A99      		sbic 0x3,2
 382 0154 00C0      		rjmp .L55
 383 0156 40E0      		ldi r20,0
 384 0158 50E4      		ldi r21,lo8(64)
 385 015a 60E0      		ldi r22,0
 386 015c 70E0      		ldi r23,0
 387               	.L27:
 130:matrix.c      ****            (PINB&(1<<2) ? 0 : (1UL<<14)) |
 388               		.loc 1 130 0
 389 015e 842B      		or r24,r20
 390 0160 952B      		or r25,r21
 391 0162 A62B      		or r26,r22
 392 0164 B72B      		or r27,r23
 132:matrix.c      ****            (PINB&(1<<0) ? 0 : (1UL<<16)) |
 393               		.loc 1 132 0
 394 0166 1999      		sbic 0x3,1
 395 0168 00C0      		rjmp .L56
 396 016a 40E0      		ldi r20,0
 397 016c 50E8      		ldi r21,lo8(-128)
 398 016e 60E0      		ldi r22,0
 399 0170 70E0      		ldi r23,0
 400               	.L28:
 131:matrix.c      ****            (PINB&(1<<1) ? 0 : (1UL<<15)) |
 401               		.loc 1 131 0
 402 0172 842B      		or r24,r20
 403 0174 952B      		or r25,r21
 404 0176 A62B      		or r26,r22
 405 0178 B72B      		or r27,r23
 133:matrix.c      ****            (PINE&(1<<6) ? 0 : (1UL<<17));
 406               		.loc 1 133 0
 407 017a 1899      		sbic 0x3,0
 408 017c 00C0      		rjmp .L57
 409 017e 40E0      		ldi r20,0
 410 0180 50E0      		ldi r21,0
 411 0182 61E0      		ldi r22,lo8(1)
 412 0184 70E0      		ldi r23,0
 413               	.L29:
 132:matrix.c      ****            (PINB&(1<<0) ? 0 : (1UL<<16)) |
 414               		.loc 1 132 0
 415 0186 842B      		or r24,r20
 416 0188 952B      		or r25,r21
 417 018a A62B      		or r26,r22
 418 018c B72B      		or r27,r23
 134:matrix.c      **** }
 419               		.loc 1 134 0
 420 018e 6699      		sbic 0xc,6
 421 0190 00C0      		rjmp .L58
 422 0192 40E0      		ldi r20,0
 423 0194 50E0      		ldi r21,0
 424 0196 62E0      		ldi r22,lo8(2)
 425 0198 70E0      		ldi r23,0
 426               	.L30:
 133:matrix.c      ****            (PINE&(1<<6) ? 0 : (1UL<<17));
 427               		.loc 1 133 0
 428 019a 842B      		or r24,r20
 429 019c 952B      		or r25,r21
 430 019e A62B      		or r26,r22
 431 01a0 B72B      		or r27,r23
 432               	.LBE40:
 433               	.LBE39:
  69:matrix.c      ****             matrix_debouncing[i] = cols;
 434               		.loc 1 69 0
 435 01a2 F701      		movw r30,r14
 436 01a4 4191      		ld r20,Z+
 437 01a6 5191      		ld r21,Z+
 438 01a8 6191      		ld r22,Z+
 439 01aa 7191      		ld r23,Z+
 440 01ac 7F01      		movw r14,r30
 441 01ae 4817      		cp r20,r24
 442 01b0 5907      		cpc r21,r25
 443 01b2 6A07      		cpc r22,r26
 444 01b4 7B07      		cpc r23,r27
 445 01b6 01F0      		breq .L31
  70:matrix.c      ****             if (debouncing) {
 446               		.loc 1 70 0
 447 01b8 3497      		sbiw r30,4
 448 01ba 8083      		st Z,r24
 449 01bc 9183      		std Z+1,r25
 450 01be A283      		std Z+2,r26
 451 01c0 B383      		std Z+3,r27
  71:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 452               		.loc 1 71 0
 453 01c2 8091 0000 		lds r24,debouncing
 454 01c6 8823      		tst r24
 455 01c8 01F0      		breq .L33
  72:matrix.c      ****             }
 456               		.loc 1 72 0
 457 01ca 8091 0000 		lds r24,debug_config
 458 01ce 80FF      		sbrs r24,0
 459 01d0 00C0      		rjmp .L34
  72:matrix.c      ****             }
 460               		.loc 1 72 0 is_stmt 0 discriminator 1
 461 01d2 80E0      		ldi r24,lo8(__c.1887)
 462 01d4 90E0      		ldi r25,hi8(__c.1887)
 463 01d6 0E94 0000 		call xputs
 464               	.LVL8:
 465               	.L34:
  72:matrix.c      ****             }
 466               		.loc 1 72 0 discriminator 3
 467 01da 8091 0000 		lds r24,debug_config
 468 01de 80FF      		sbrs r24,0
 469 01e0 00C0      		rjmp .L35
  72:matrix.c      ****             }
 470               		.loc 1 72 0 discriminator 4
 471 01e2 8091 0000 		lds r24,debouncing
 472 01e6 1F92      		push __zero_reg__
 473               	.LCFI5:
 474               		.cfi_def_cfa_offset 8
 475 01e8 8F93      		push r24
 476               	.LCFI6:
 477               		.cfi_def_cfa_offset 9
 478 01ea 80E0      		ldi r24,lo8(__c.1889)
 479 01ec 90E0      		ldi r25,hi8(__c.1889)
 480 01ee 9F93      		push r25
 481               	.LCFI7:
 482               		.cfi_def_cfa_offset 10
 483 01f0 8F93      		push r24
 484               	.LCFI8:
 485               		.cfi_def_cfa_offset 11
 486 01f2 0E94 0000 		call __xprintf
 487               	.LVL9:
 488 01f6 0F90      		pop __tmp_reg__
 489 01f8 0F90      		pop __tmp_reg__
 490 01fa 0F90      		pop __tmp_reg__
 491 01fc 0F90      		pop __tmp_reg__
 492               	.LCFI9:
 493               		.cfi_def_cfa_offset 7
 494               	.L35:
  72:matrix.c      ****             }
 495               		.loc 1 72 0 discriminator 6
 496 01fe 8091 0000 		lds r24,debug_config
 497 0202 80FF      		sbrs r24,0
 498 0204 00C0      		rjmp .L33
  72:matrix.c      ****             }
 499               		.loc 1 72 0 discriminator 7
 500 0206 80E0      		ldi r24,lo8(__c.1891)
 501 0208 90E0      		ldi r25,hi8(__c.1891)
 502 020a 0E94 0000 		call xputs
 503               	.LVL10:
 504               	.L33:
  74:matrix.c      ****         }
 505               		.loc 1 74 0 is_stmt 1
 506 020e 85E0      		ldi r24,lo8(5)
 507 0210 8093 0000 		sts debouncing,r24
 508               	.L31:
  76:matrix.c      ****     }
 509               		.loc 1 76 0 discriminator 2
 510 0214 0E94 0000 		call unselect_rows
 511               	.LVL11:
 512               	.LBE33:
  65:matrix.c      ****         select_row(i);
 513               		.loc 1 65 0 discriminator 2
 514 0218 1F5F      		subi r17,lo8(-(1))
 515               	.LVL12:
 516 021a 1630      		cpi r17,lo8(6)
 517 021c 01F0      		breq .+2
 518 021e 00C0      		rjmp .L37
 519               	.LBE32:
  79:matrix.c      ****         if (--debouncing) {
 520               		.loc 1 79 0
 521 0220 8091 0000 		lds r24,debouncing
 522 0224 8823      		tst r24
 523 0226 01F0      		breq .L40
  80:matrix.c      ****             _delay_ms(1);
 524               		.loc 1 80 0
 525 0228 8150      		subi r24,lo8(-(-1))
 526 022a 8093 0000 		sts debouncing,r24
 527 022e E0E0      		ldi r30,lo8(matrix)
 528 0230 F0E0      		ldi r31,hi8(matrix)
 529 0232 8823      		tst r24
 530 0234 01F4      		brne .+2
 531 0236 00C0      		rjmp .L41
 532               	.LVL13:
 533               	.LBB45:
 534               	.LBB46:
 187:c:\avr-gcc-7.2.0-x64-mingw\avr\include\util\delay.h **** 
 535               		.loc 2 187 0
 536 0238 8FE9      		ldi r24,lo8(3999)
 537 023a 9FE0      		ldi r25,hi8(3999)
 538 023c 0197      	1:	sbiw r24,1
 539 023e 01F4      		brne 1b
 540 0240 00C0      		rjmp .
 541 0242 0000      		nop
 542               	.LVL14:
 543               	.L40:
 544               	.LBE46:
 545               	.LBE45:
  90:matrix.c      **** 
 546               		.loc 1 90 0
 547 0244 81E0      		ldi r24,lo8(1)
 548               	/* epilogue start */
 549 0246 DF91      		pop r29
 550 0248 CF91      		pop r28
 551 024a 1F91      		pop r17
 552               	.LVL15:
 553 024c FF90      		pop r15
 554 024e EF90      		pop r14
 555 0250 0895      		ret
 556               	.LVL16:
 557               	.L8:
 558               	.LBB47:
 559               	.LBB44:
 560               	.LBB42:
 561               	.LBB36:
 151:matrix.c      ****         case 0:
 562               		.loc 1 151 0
 563 0252 1430      		cpi r17,lo8(4)
 564 0254 01F0      		breq .L11
 565 0256 1530      		cpi r17,lo8(5)
 566 0258 01F0      		breq .+2
 567 025a 00C0      		rjmp .L6
 155:matrix.c      ****             break;
 156:matrix.c      ****         case 1:
 157:matrix.c      ****             DDRF  |= (1<<1);
 158:matrix.c      ****             PORTF &= ~(1<<1);
 159:matrix.c      ****             break;
 160:matrix.c      ****         case 2:
 161:matrix.c      ****             DDRF  |= (1<<4);
 162:matrix.c      ****             PORTF &= ~(1<<4);
 163:matrix.c      ****             break;
 164:matrix.c      ****         case 3:
 165:matrix.c      ****             DDRF  |= (1<<5);
 166:matrix.c      ****             PORTF &= ~(1<<5);
 167:matrix.c      ****             break;
 168:matrix.c      ****         case 4:
 169:matrix.c      ****             DDRF  |= (1<<6);
 170:matrix.c      ****             PORTF &= ~(1<<6);
 171:matrix.c      ****             break;
 172:matrix.c      **** 		case 5:
 173:matrix.c      **** 			DDRF  |= (1<<7);
 568               		.loc 1 173 0
 569 025c 879A      		sbi 0x10,7
 174:matrix.c      **** 			PORTF &= ~(1<<7);
 570               		.loc 1 174 0
 571 025e 8F98      		cbi 0x11,7
 572 0260 00C0      		rjmp .L13
 573               	.L9:
 157:matrix.c      ****             PORTF &= ~(1<<1);
 574               		.loc 1 157 0
 575 0262 819A      		sbi 0x10,1
 158:matrix.c      ****             break;
 576               		.loc 1 158 0
 577 0264 8998      		cbi 0x11,1
 578 0266 00C0      		rjmp .L13
 579               	.L10:
 161:matrix.c      ****             PORTF &= ~(1<<4);
 580               		.loc 1 161 0
 581 0268 849A      		sbi 0x10,4
 162:matrix.c      ****             break;
 582               		.loc 1 162 0
 583 026a 8C98      		cbi 0x11,4
 584 026c 00C0      		rjmp .L13
 585               	.L7:
 165:matrix.c      ****             PORTF &= ~(1<<5);
 586               		.loc 1 165 0
 587 026e 859A      		sbi 0x10,5
 166:matrix.c      ****             break;
 588               		.loc 1 166 0
 589 0270 8D98      		cbi 0x11,5
 590 0272 00C0      		rjmp .L13
 591               	.L11:
 169:matrix.c      ****             PORTF &= ~(1<<6);
 592               		.loc 1 169 0
 593 0274 869A      		sbi 0x10,6
 170:matrix.c      ****             break;
 594               		.loc 1 170 0
 595 0276 8E98      		cbi 0x11,6
 596 0278 00C0      		rjmp .L13
 597               	.LVL17:
 598               	.L42:
 599               	.LBE36:
 600               	.LBE42:
 601               	.LBB43:
 602               	.LBB41:
 118:matrix.c      ****            (PINB&(1<<4) ? 0 : (1UL<<2)) |
 603               		.loc 1 118 0
 604 027a 40E0      		ldi r20,0
 605 027c 50E0      		ldi r21,0
 606 027e BA01      		movw r22,r20
 607 0280 00C0      		rjmp .L14
 608               	.L43:
 119:matrix.c      ****            (PIND&(1<<7) ? 0 : (1UL<<3)) |
 609               		.loc 1 119 0
 610 0282 40E0      		ldi r20,0
 611 0284 50E0      		ldi r21,0
 612 0286 BA01      		movw r22,r20
 613 0288 00C0      		rjmp .L15
 614               	.L44:
 120:matrix.c      ****            (PIND&(1<<4) ? 0 : (1UL<<4)) |
 615               		.loc 1 120 0
 616 028a 40E0      		ldi r20,0
 617 028c 50E0      		ldi r21,0
 618 028e BA01      		movw r22,r20
 619 0290 00C0      		rjmp .L16
 620               	.L45:
 121:matrix.c      ****            (PIND&(1<<5) ? 0 : (1UL<<5)) |
 621               		.loc 1 121 0
 622 0292 40E0      		ldi r20,0
 623 0294 50E0      		ldi r21,0
 624 0296 BA01      		movw r22,r20
 625 0298 00C0      		rjmp .L17
 626               	.L46:
 122:matrix.c      ****            (PINC&(1<<7) ? 0 : (1UL<<6)) |
 627               		.loc 1 122 0
 628 029a 40E0      		ldi r20,0
 629 029c 50E0      		ldi r21,0
 630 029e BA01      		movw r22,r20
 631 02a0 00C0      		rjmp .L18
 632               	.L47:
 123:matrix.c      ****            (PINC&(1<<6) ? 0 : (1UL<<7)) |
 633               		.loc 1 123 0
 634 02a2 40E0      		ldi r20,0
 635 02a4 50E0      		ldi r21,0
 636 02a6 BA01      		movw r22,r20
 637 02a8 00C0      		rjmp .L19
 638               	.L48:
 124:matrix.c      ****            (PIND&(1<<3) ? 0 : (1UL<<8)) |
 639               		.loc 1 124 0
 640 02aa 40E0      		ldi r20,0
 641 02ac 50E0      		ldi r21,0
 642 02ae BA01      		movw r22,r20
 643 02b0 00C0      		rjmp .L20
 644               	.L49:
 125:matrix.c      ****            (PIND&(1<<2) ? 0 : (1UL<<9)) |
 645               		.loc 1 125 0
 646 02b2 40E0      		ldi r20,0
 647 02b4 50E0      		ldi r21,0
 648 02b6 BA01      		movw r22,r20
 649 02b8 00C0      		rjmp .L21
 650               	.L50:
 126:matrix.c      ****            (PIND&(1<<1) ? 0 : (1UL<<10)) |
 651               		.loc 1 126 0
 652 02ba 40E0      		ldi r20,0
 653 02bc 50E0      		ldi r21,0
 654 02be BA01      		movw r22,r20
 655 02c0 00C0      		rjmp .L22
 656               	.L51:
 127:matrix.c      ****            (PIND&(1<<0) ? 0 : (1UL<<11)) |
 657               		.loc 1 127 0
 658 02c2 40E0      		ldi r20,0
 659 02c4 50E0      		ldi r21,0
 660 02c6 BA01      		movw r22,r20
 661 02c8 00C0      		rjmp .L23
 662               	.L52:
 128:matrix.c      ****            (PINB&(1<<7) ? 0 : (1UL<<12)) |
 663               		.loc 1 128 0
 664 02ca 40E0      		ldi r20,0
 665 02cc 50E0      		ldi r21,0
 666 02ce BA01      		movw r22,r20
 667 02d0 00C0      		rjmp .L24
 668               	.L53:
 129:matrix.c      ****            (PINB&(1<<3) ? 0 : (1UL<<13)) |
 669               		.loc 1 129 0
 670 02d2 40E0      		ldi r20,0
 671 02d4 50E0      		ldi r21,0
 672 02d6 BA01      		movw r22,r20
 673 02d8 00C0      		rjmp .L25
 674               	.L54:
 130:matrix.c      ****            (PINB&(1<<2) ? 0 : (1UL<<14)) |
 675               		.loc 1 130 0
 676 02da 40E0      		ldi r20,0
 677 02dc 50E0      		ldi r21,0
 678 02de BA01      		movw r22,r20
 679 02e0 00C0      		rjmp .L26
 680               	.L55:
 131:matrix.c      ****            (PINB&(1<<1) ? 0 : (1UL<<15)) |
 681               		.loc 1 131 0
 682 02e2 40E0      		ldi r20,0
 683 02e4 50E0      		ldi r21,0
 684 02e6 BA01      		movw r22,r20
 685 02e8 00C0      		rjmp .L27
 686               	.L56:
 132:matrix.c      ****            (PINB&(1<<0) ? 0 : (1UL<<16)) |
 687               		.loc 1 132 0
 688 02ea 40E0      		ldi r20,0
 689 02ec 50E0      		ldi r21,0
 690 02ee BA01      		movw r22,r20
 691 02f0 00C0      		rjmp .L28
 692               	.L57:
 133:matrix.c      ****            (PINE&(1<<6) ? 0 : (1UL<<17));
 693               		.loc 1 133 0
 694 02f2 40E0      		ldi r20,0
 695 02f4 50E0      		ldi r21,0
 696 02f6 BA01      		movw r22,r20
 697 02f8 00C0      		rjmp .L29
 698               	.L58:
 134:matrix.c      **** }
 699               		.loc 1 134 0
 700 02fa 40E0      		ldi r20,0
 701 02fc 50E0      		ldi r21,0
 702 02fe BA01      		movw r22,r20
 703 0300 00C0      		rjmp .L30
 704               	.LVL18:
 705               	.L41:
 706               	.LBE41:
 707               	.LBE43:
 708               	.LBE44:
 709               	.LBE47:
 710               	.LBB48:
  84:matrix.c      ****             }
 711               		.loc 1 84 0 discriminator 3
 712 0302 8991      		ld r24,Y+
 713 0304 9991      		ld r25,Y+
 714 0306 A991      		ld r26,Y+
 715 0308 B991      		ld r27,Y+
 716 030a 8193      		st Z+,r24
 717 030c 9193      		st Z+,r25
 718 030e A193      		st Z+,r26
 719 0310 B193      		st Z+,r27
 720               	.LVL19:
  83:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 721               		.loc 1 83 0 discriminator 3
 722 0312 90E0      		ldi r25,hi8(matrix_debouncing+24)
 723 0314 C030      		cpi r28,lo8(matrix_debouncing+24)
 724 0316 D907      		cpc r29,r25
 725 0318 01F4      		brne .L41
 726 031a 00C0      		rjmp .L40
 727               	.LBE48:
 728               		.cfi_endproc
 729               	.LFE8:
 731               		.section	.text.matrix_get_row,"ax",@progbits
 732               	.global	matrix_get_row
 734               	matrix_get_row:
 735               	.LFB9:
  94:matrix.c      ****     return matrix[row];
 736               		.loc 1 94 0
 737               		.cfi_startproc
 738               	.LVL20:
 739               	/* prologue: function */
 740               	/* frame size = 0 */
 741               	/* stack size = 0 */
 742               	.L__stack_usage = 0
  95:matrix.c      **** }
 743               		.loc 1 95 0
 744 0000 94E0      		ldi r25,lo8(4)
 745 0002 899F      		mul r24,r25
 746 0004 F001      		movw r30,r0
 747 0006 1124      		clr __zero_reg__
 748 0008 E050      		subi r30,lo8(-(matrix))
 749 000a F040      		sbci r31,hi8(-(matrix))
 750 000c 6081      		ld r22,Z
 751 000e 7181      		ldd r23,Z+1
 752 0010 8281      		ldd r24,Z+2
 753 0012 9381      		ldd r25,Z+3
 754               	/* epilogue start */
  96:matrix.c      **** 
 755               		.loc 1 96 0
 756 0014 0895      		ret
 757               		.cfi_endproc
 758               	.LFE9:
 760               		.section	.progmem.data.__c.1891,"a",@progbits
 763               	__c.1891:
 764 0000 0A00      		.string	"\n"
 765               		.section	.progmem.data.__c.1889,"a",@progbits
 768               	__c.1889:
 769 0000 2530 3258 		.string	"%02X"
 769      00
 770               		.section	.progmem.data.__c.1887,"a",@progbits
 773               	__c.1887:
 774 0000 626F 756E 		.string	"bounce!: "
 774      6365 213A 
 774      2000 
 775               		.section	.bss.matrix_debouncing,"aw",@nobits
 778               	matrix_debouncing:
 779 0000 0000 0000 		.zero	24
 779      0000 0000 
 779      0000 0000 
 779      0000 0000 
 779      0000 0000 
 780               		.section	.bss.matrix,"aw",@nobits
 783               	matrix:
 784 0000 0000 0000 		.zero	24
 784      0000 0000 
 784      0000 0000 
 784      0000 0000 
 784      0000 0000 
 785               		.section	.data.debouncing,"aw",@progbits
 788               	debouncing:
 789 0000 05        		.byte	5
 790               		.text
 791               	.Letext0:
 792               		.file 3 "c:\\avr-gcc-7.2.0-x64-mingw\\avr\\include\\stdint.h"
 793               		.file 4 "../../tmk_core/common/debug.h"
 794               		.file 5 "../../tmk_core/common/avr/xprintf.h"
 795               		.file 6 "../../tmk_core/common/matrix.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
C:\cygwin\tmp\ccYIkFSY.s:2      *ABS*:000000000000003e __SP_H__
C:\cygwin\tmp\ccYIkFSY.s:3      *ABS*:000000000000003d __SP_L__
C:\cygwin\tmp\ccYIkFSY.s:4      *ABS*:000000000000003f __SREG__
C:\cygwin\tmp\ccYIkFSY.s:5      *ABS*:0000000000000000 __tmp_reg__
C:\cygwin\tmp\ccYIkFSY.s:6      *ABS*:0000000000000001 __zero_reg__
C:\cygwin\tmp\ccYIkFSY.s:12     .text.unselect_rows:0000000000000000 unselect_rows
C:\cygwin\tmp\ccYIkFSY.s:38     .text.matrix_init:0000000000000000 matrix_init
C:\cygwin\tmp\ccYIkFSY.s:783    .bss.matrix:0000000000000000 matrix
C:\cygwin\tmp\ccYIkFSY.s:778    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
C:\cygwin\tmp\ccYIkFSY.s:121    .text.matrix_scan:0000000000000000 matrix_scan
C:\cygwin\tmp\ccYIkFSY.s:788    .data.debouncing:0000000000000000 debouncing
C:\cygwin\tmp\ccYIkFSY.s:773    .progmem.data.__c.1887:0000000000000000 __c.1887
C:\cygwin\tmp\ccYIkFSY.s:768    .progmem.data.__c.1889:0000000000000000 __c.1889
C:\cygwin\tmp\ccYIkFSY.s:763    .progmem.data.__c.1891:0000000000000000 __c.1891
C:\cygwin\tmp\ccYIkFSY.s:734    .text.matrix_get_row:0000000000000000 matrix_get_row

UNDEFINED SYMBOLS
debug_config
xputs
__xprintf
__do_copy_data
__do_clear_bss
